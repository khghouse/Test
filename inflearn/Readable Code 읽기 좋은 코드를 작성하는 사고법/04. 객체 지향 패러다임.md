
## 추상의 관점으로 바라보는 객체 지향

절차 지향
- 정해진 순서, 차례대로 컴퓨터 처리 구조와 유사하게 처리하는 프로그래밍

객체 지향
- 객체간 협력을 통해 프로그래밍이 이루어지는 프로그래밍

함수형
- 사이드 이팩트가 없는 순수 함수 기반의 프로그래밍
- 같은 값을 입력하면 항상 같은 값이 리턴

객체 (Object)
- 어떤 목적을 가지고 추상화된 것
  
캡슐화
- 객체 내부 로직을 숨기고 그 일부만 외부에 공개
  
관심사의 분리
- 관심사에 따라 객체를 생성하고, 역할과 책임을 갖는 객체의 조합으로 프로그램이 동작하도록 하는 것
  - 유지 보수가 원활해진다.
  - 높은 응집도 : 관심사를 모았을 때, 응집도가 높아진다.
  - 낮은 결합도 : 관심사가 분리되면 객체간 결합도가 낮아진다.
  
<br />

## 객체 설계하기

객체로 추상화하기
- 비공개 필드 (데이터)
- 비공개 로직 (코드)
- 공개 메서드 선언부를 통해 외부 소통
- 객체의 책임이 나뉨에 따라 객체 간 협력이 발생

객체가 제공하는 것
- 관심사가 한군데로 모임으로써 유지보수성 증가
- 구체적인 구현에 신경 쓰지 않고(캡슐화) 보다 높은 추상화 레벨에서 기능 제공

새로운 객체를 만들 때 주의할 점
- 1개의 관심사로 명확하게 책임을 정의했는지 확인
  - 외부와 어떻게 소통할지 고민
- 생성자, 정적 팩토리 메서드를 에서 유효성 검증이 가능하다.
  - 도메인에 특화된 검증 로직이 들어갈 수 있다.
- setter 사용 자제
- getter는 필요한 순간에 추가
```java
if (person.get지갑().get신분증().findAge() >= 19) {
    pass();
}

// 객체에 메세지를 보내자
if (person.isAgeGreaterThanOrEqualTo(19)) {
    pass();
}
```
- 필드의 수는 적을수록 좋다.
  - 불필요한 데이터가 많을수록 복잡해지고 유지보수성이 떨어진다.
```java
class Bill {
    private final List<Menu> menus;
    private final long totalPrice;
    
    // 메뉴의 총 금액 계산을 메서드로 제공
    // 필드를 메서드로 대체
    public long calculateTotalPrice() {
        return this.menus.stream()
                .mapToLong(Menu::getPrice)
                .sum();
    }
    
    // 단, 메서드의 계산 로직이 너무 복잡하고 성능에 이슈가 있다면 필드로 분리
}
```

<br />

## SOLID

- SRP : 단일 책임 원칙 
- OCP : 개방 폐쇄 원칙
- LSP : 리스코프 치환 원칙
- ISP : 인터페이스 분리 원칙
- DIP : 의존성 역전 원칙

## SRP : Single Responsibility Principle

단일 책임 원칙
- 하나의 클래스는 하나의 책임만 갖도록 한다.

<br />

## OCP : Open Closed Principle

개방 폐쇄 원칙
- 확장에는 열려 있고, 수정에는 닫혀 있어야 한다.
  - 기존 코드의 변경 없이 (수정 closed) 시스템의 기능을 확장할 수 있어야 한다. (확장 open)

<br />

## LSP : Liskov Substitution Principle

리스코프 치환 원칙
- 상속 구조에서 부모 인스턴스를 자식 인스턴스로 치환할 수 있어야 한다.
- 자식 클래스는 부모 클래스의 책임을 준수하며, 부모 클래스의 행동을 변경하지 않아야 한다.

<br />

## ISP : Interface Segregation Principle

인터페이스 분리 원칙
- 인터페이스의 일부 기능만 구현하는 구현체가 존재한다면 인터페이스를 분리해야 한다.
```java
interface AB {
    a();
    b();
}

class AClass implements AB {
    a() { }
    b() { }
}

class BClass implements AB {
    a() { }
    b() { } // 구현은 하되, 사용하지 않음 -> 이때 인터페이스를 다시 돌아보고 분리할지 고민해 봐야 한다.
```
```java
// 인터페이스 분리
interface A {
    a();
}

interface B {
    b();
}

class AClass implements A, B {
    a() { }
    b() { }
}

class BClass implements A {
    a() { }
```
- ISP를 위반하면 불필요한 의존성으로 인해 결합도가 높아지고, 특정 기능 변경으로 (인터페이스 메서드 시그니처 변경) 여러 클래스에 영향을 미칠 수 있다.

<br />

## DIP : Dependency Inversion Principle

의존성 역전 원칙
- 상위 수준의 모듈은 하위 수준의 모듈에 의존해서는 안 된다.
- 둘 다 추상화에 의존해야 한다.

의존성 : 하나의 모듈이 다른 하나의 모듈을 알고 있거나 직접적으로 생성, 사용하는 것
- 의존성의 순방향 : 고수준 모듈이 저소준 모듈을 참조하는 것
  - 저수준 모듈을 자주 바뀔 수 있다. -> 고수준 모듈에 영향이 간다.
- 의존성의 역방향 : 고수준 모듈과 저수준 모듈이 직접적으로 의존하지 않도록 추상화를 중간에 두고 의존하도록 하는 것
  - 저수준 모듈 변경되어도 고수준 모듈에 영향이 가지 않는다.

(상위 수준의 모듈 = 고수준 모듈 = 추상화 레벨이 높음)

<br />

## 키워드 정리

- 객체, 협력과 책임, 관심사의 분리, 높은 응집도와 낮은 결합도
- getter/setter 자제하기, 객체에 메시지 보내기
- SOLID : SRP, OCP, LSP, ISP, DIP
- DI/Ioc
