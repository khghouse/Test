
## 추상의 관점으로 바라보는 객체 지향

절차 지향
- 정해진 순서, 차례대로 컴퓨터 처리 구조와 유사하게 처리하는 프로그래밍

객체 지향
- 객체간 협력을 통해 프로그래밍이 이루어지는 프로그래밍

함수형
- 사이드 이팩트가 없는 순수 함수 기반의 프로그래밍
- 같은 값을 입력하면 항상 같은 값이 리턴

객체 (Object)
  - 어떤 목적을 가지고 추상화된 것
  
  캡슐화
  - 객체 내부 로직을 숨기고 그 일부만 외부에 공개
  
  관심사의 분리
  - 관심사에 따라 객체를 생성하고, 역할과 책임을 갖는 객체의 조합으로 프로그램이 동작하도록 하는 것
    - 유지 보수가 원활해진다.
    - 높은 응집도 : 관심사를 모았을 때, 응집도가 높아진다.
    - 낮은 결합도 : 관심사가 분리되면 객체간 결합도가 낮아진다.
  
  <br />
  
  ## 객체 설계하기

객체로 추상화하기
- 비공개 필드 (데이터)
- 비공개 로직 (코드)
- 공개 메서드 선언부를 통해 외부 소통
- 객체의 책임이 나뉨에 따라 객체간 협력이 발생

객체가 제공하는 것
- 관심사가 한군데로 모임으로써 유지보수성 증가
- 구체적인 구현에 신경 쓰지 않고(캡슐화) 보다 높은 추상화 레벨에서 기능 제공

새로운 객체를 만들 때 주의할 점
- 1개의 관심사로 명확하게 책임을 정의했는지 확인
  - 외부와 어떻게 소통할지 고민
- 생성자, 정적 팩토리 메서드를 에서 유효성 검증이 가능하다.
  - 도메인에 특화된 검증 로직이 들어갈 수 있다.
- setter 사용 자제
- getter는 필요한 순간에 추가
```java
if (person.get지갑().get신분증().findAge() >= 19) {
    pass();
}

// 객체에 메세지를 보내자
if (person.isAgeGreaterThanOrEqualTo(19)) {
    pass();
}
```
- 필드의 수는 적을수록 좋다.
  - 불필요한 데이터가 많을수록 복잡해지고 유지보수성이 떨어진다.
```java
class Bill {
    private final List<Menu> menus;
    private final long totalPrice;
    
    // 메뉴의 총 금액 계산을 메서드로 제공
    // 필드를 메서드로 대체
    public long calculateTotalPrice() {
        return this.menus.stream()
                .mapToLong(Menu::getPrice)
                .sum();
    }
    
    // 단, 메서드의 계산 로직이 너무 복잡하고 성능에 이슈가 있다면 필드로 분리
}
```

